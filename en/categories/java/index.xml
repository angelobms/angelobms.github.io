<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Java on My Personal Website</title>
    <link>http://localhost:1313/en/categories/java/</link>
    <description>Recent content in Java on My Personal Website</description>
    <generator>Hugo -- 0.150.0</generator>
    <language>en</language>
    <lastBuildDate>Wed, 24 Sep 2025 18:59:31 -0300</lastBuildDate>
    <atom:link href="http://localhost:1313/en/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Building Resilient, Fault-Tolerant Applications with Quarkus</title>
      <link>http://localhost:1313/en/posts/building-resilient-fault-tolerant-applications-with-quarkus/</link>
      <pubDate>Wed, 24 Sep 2025 18:59:31 -0300</pubDate>
      <guid>http://localhost:1313/en/posts/building-resilient-fault-tolerant-applications-with-quarkus/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Anyone who develops microservices knows: failures happen. Dropped connections, slow external services, congested queues â€” all of this can compromise a system&amp;rsquo;s availability.&lt;/p&gt;
&lt;p&gt;Quarkus, in addition to being fast and optimized for native Kubernetes environments, already comes with support for resilience features through MicroProfile Fault Tolerance. This means we can apply classic fault tolerance patterns to our applications with just a few annotations.&lt;/p&gt;
&lt;p&gt;In this article, I&amp;rsquo;ll show you how to implement these patterns practically, with code examples and tips that can save your application in production environments.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
